// ==UserScript==
// @name         MHW ASS - Professional Build Card (Interactive)
// @namespace    http://tampermonkey.net/
// @version      5.2
// @description  Interactive build card: TinyURL shortening, bottom-left QR positioning, and zero-slot filtering. Fixed deco parsing and slot assignment.
// @match         *://*.wiki-db.com/sim/*
// @grant         none
// @require       https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js
// @require       https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js
// ==/UserScript==

(function() {
    'use strict';

    const ICONS = {
        1: 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/deco_1.webp',
        2: 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/deco_2.webp',
        3: 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/deco_3.webp',
        4: 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/deco_4.webp',
        'GS': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_0.png',
        'LS': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_1.png',
        'SnS': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_2.png',
        'DB': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_3.png',
        'Ham': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_4.png',
        'HH': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_5.png',
        'LNC': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_6.png',
        'GL': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_7.png',
        'SWA': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_8.png',
        'CB': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_9.png',
        'IG': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_10.png',
        'LBG': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_12.png',
        'HBG': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_13.png',
        'Bow': 'https://raw.githubusercontent.com/Maybe-a/IconsforSearcher/refs/heads/main/Images/weapon_type_11.png',
        'HELM': '/static/mhsim/simicons/head.png'
    };

    let selectedDeco = null;
    let jewelInventory = [];
    let isLegacyMode = false;

    const style = document.createElement('style');
    style.innerHTML = `
        .mhw-card-wrapper {
            display: flex; flex-direction: column; gap: 15px; background-color: #0c0c0c; color: #efefef;
            font-family: 'Segoe UI', sans-serif; padding: 35px; border-radius: 4px;
            border: 1px solid #222; margin: 20px 0; width: 1050px;
            position: relative; overflow: hidden;
            padding-bottom: 120px; /* Added height to prevent QR from clipping into skills/bank */
        }
        .mhw-build-title-display { font-size: 2.2em; font-weight: bold; color: #fff; border-bottom: 2px solid #3498db; margin-bottom: 15px; padding-bottom: 5px; }
        .mhw-main-row { display: flex; gap: 25px; }
        .mhw-column { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .mhw-section-title { font-size: 0.75em; text-transform: uppercase; color: #666; border-bottom: 1px solid #222; margin-bottom: 8px; padding-bottom: 4px; display: flex; justify-content: space-between; align-items: center; }

        .mhw-piece-group { display: flex; flex-direction: column; background: #181818; border-left: 4px solid #3498db; margin-bottom: 2px; }
        .mhw-piece-header { padding: 10px 14px; display: flex; align-items: center; gap: 10px; font-size: 0.9em; font-weight: 600; }
        .mhw-innate-skills { margin-left: auto; color: #888; font-size: 0.85em; font-weight: normal; font-style: italic; }

        .mhw-slot-row { display: flex; border-top: 1px solid #222; background: #111; padding: 2px 0; }
        .mhw-slot-box {
            flex: 1; padding: 8px 12px; border-right: 1px solid #222; min-height: 38px;
            display: flex; align-items: center; gap: 8px; font-size: 0.85em; cursor: pointer; color: #555; transition: 0.2s;
        }
        .mhw-slot-box:last-child { border-right: none; }
        .mhw-slot-box:hover { background: #222; }
        .mhw-slot-filled { color: #fff; font-weight: normal; }

        .mhw-icon-img { height: 20px; width: 20px; object-fit: contain; }

        .mhw-deco-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .mhw-deco-btn {
            background: #181818; padding: 10px; display: flex; align-items: center;
            justify-content: space-between; cursor: pointer; border-radius: 2px; border: 1px solid transparent;
        }
        .mhw-deco-btn:hover { border-color: #3498db; background: #222; }
        .mhw-deco-btn.selected { border-color: #3498db; background: #1a2a3a; outline: 1px solid #3498db; }
        .mhw-deco-name { font-size: 0.85em; display: flex; align-items: center; gap: 8px; }
        .mhw-deco-qty { color: #f1c40f; font-weight: bold; }

        .mhw-skill-item { background: #181818; padding: 8px 14px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #3498db;}
        .mhw-skill-lv { color: #f1c40f; font-weight: bold; font-size: 0.9em; }

        .mhw-overcap-legend { font-size: 0.7em; color: #888; margin-top: 5px; font-style: italic; }

        .mhw-qr-container {
            position: absolute;
            bottom: 25px;
            left: 25px;
            width: 90px; height: 90px;
            background: #fff; padding: 6px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 4px;
            z-index: 100;
        }
        .mhw-qr-container canvas, .mhw-qr-container img { width: 78px !important; height: 78px !important; }

        .mhw-controls { display: flex; flex-wrap: wrap; gap: 12px; margin: 15px 0; background: #1a1a1a; padding: 15px; border-radius: 5px; border: 1px solid #333; align-items: center; }
        .mhw-input, .mhw-select { background: #000; color: white; border: 1px solid #444; padding: 8px 12px; border-radius: 3px; }
        .mhw-action-btn { background: #3498db; color: #fff; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; font-weight: bold; }
        .mhw-dl-btn { background: #27ae60; }
        .mhw-legacy-toggle { display: flex; align-items: center; gap: 8px; color: #888; font-size: 0.85em; cursor: pointer; }
    `;
    document.head.appendChild(style);

    async function shortenUrl(longUrl) {
        try {
            const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(longUrl)}`);
            if (response.ok) return await response.text();
        } catch (e) { console.error("TinyURL failed", e); }
        return longUrl;
    }

    function parseSlots(str) {
        if (!str || str === "0-0-0" || str === "--" || str === "0") return [];
        if (isLegacyMode) {
            const flatVal = str.replace(/[\[\]\s]/g, '');
            if (/^\d$/.test(flatVal) && flatVal !== "0") return [parseInt(flatVal)];
            if (str.includes('O')) return [1];
        }
        if (/^\d-\d-\d$/.test(str)) {
             return str.split('-').map(Number).filter(n => n > 0);
        }
        return [];
    }

    function extractData(containerDiv) {
        const tables = containerDiv.querySelectorAll('table');
        if (tables.length < 2) return null;

        let equipment = [];
        let rawDecos = "";

        tables[0].querySelectorAll('tr').forEach(tr => {
            const firstCell = tr.querySelector('td:first-child');
            if (firstCell && firstCell.innerText.trim().includes("Deco")) {
                // Extract decorations from the span elements
                const decoSpans = tr.querySelectorAll('span[style*="margin-right"]');
                const decoList = [];
                decoSpans.forEach(span => {
                    const text = span.innerText.trim();
                    if (text) decoList.push(text);
                });
                rawDecos = decoList.join(' ');
            } else {
                const link = tr.querySelector('td:nth-child(2) a');
                if (link) equipment.push({ name: link.innerText.trim(), img: link.querySelector('img')?.src, multiSlots: [], innate: [] });
            }
        });

        const skillRows = Array.from(tables[1].querySelectorAll('tr'));
        const slotRow = skillRows.find(tr => tr.innerText.includes("Slots"));

        if (slotRow) {
            const cells = slotRow.querySelectorAll('td');
            const parseCellSlots = (cell, isComplex = false) => {
                if (!cell) return [];
                const parts = isComplex ? cell.innerHTML.split('<br>') : [cell.innerText.trim()];
                const results = [];
                parts.forEach(p => {
                    const text = p.replace(/<[^>]*>/g, '').trim();
                    const slots = parseSlots(text);
                    if (slots.length > 0) {
                        let icon = null;
                        if (p.includes('head.png')) icon = ICONS.HELM;
                        results.push({ slots, icon });
                    }
                });
                return results;
            };

            // Map armor slot cells to equipment by matching the cell index to actual equipment index
            // Need to build a mapping since equipment array shrinks when pieces are missing
            const armorSlots = [
                { cellIndex: 2, type: 'head' },
                { cellIndex: 3, type: 'chest' },
                { cellIndex: 4, type: 'arms' },
                { cellIndex: 5, type: 'waist' },
                { cellIndex: 6, type: 'boots' }
            ];

            let equipArmorIndex = 0;
            armorSlots.forEach(({ cellIndex, type }) => {
                if (cells[cellIndex] && cells[cellIndex].innerText.trim() !== '') {
                    if (equipment[equipArmorIndex]) {
                        equipment[equipArmorIndex].multiSlots = parseCellSlots(cells[cellIndex]);
                        equipArmorIndex++;
                    }
                }
            });

            // Handle charm (always LAST in equipment array IF it exists, always at cells[7])
            const charmIndex = equipment.length - 1;
            if (charmIndex >= 0 && cells[7] && equipment[charmIndex].img && equipment[charmIndex].img.includes('charm.png')) {
                equipment[charmIndex].multiSlots = parseCellSlots(cells[7], true);
            }

            // Handle weapon (always at cells[1])
            if (cells[1]) {
                const weaponMulti = parseCellSlots(cells[1], true);
                equipment.weaponData = { multiSlots: weaponMulti, innate: [] };
            }
        }

        let skills = [];
        skillRows.forEach((tr, i) => {
            if (i === 0 || tr.innerText.includes("Slots")) return;
            const cells = tr.querySelectorAll('td');
            if (cells.length >= 11 && cells[10].innerText.trim()) {
                const name = cells[0].innerText.trim();
                const weaponPts = parseInt(cells[1].innerText) || 0;
                const charmPts = parseInt(cells[7].innerText) || 0;

                if (weaponPts > 0) equipment.weaponData.innate.push(name);
                if (charmPts > 0 && equipment[5]) equipment[5].innate.push(name);

                const lvM = cells[10].innerText.match(/Lv(\d+)/i);
                const totalPoints = parseInt(cells[9].innerText) || 0;
                const activeLevel = lvM ? parseInt(lvM[1]) : 0;
                skills.push({
                    name: name,
                    full: cells[10].innerText.trim(),
                    level: activeLevel,
                    isOvercap: lvM && totalPoints > activeLevel
                });
            }
        });
        skills.sort((a, b) => b.level - a.level);

        return { equipment, skills, decorations: rawDecos };
    }

    async function renderCard(containerDiv, data, buildName, weaponName, weaponType) {
        let card = containerDiv.querySelector('.mhw-card-wrapper') || document.createElement('div');
        card.className = 'mhw-card-wrapper';
        containerDiv.appendChild(card);

        const shortUrl = await shortenUrl(window.location.href);

        selectedDeco = null;
        jewelInventory = [];
        // Updated regex to handle combo decos with slashes like "Blaze/Handicraft Jwl [3]"
        const matches = data.decorations.matchAll(/([a-zA-Z\s\d\+\/]+?)\s*(?:\[(\d)\])?\*(\d+)/g);
        for (const m of matches) {
            jewelInventory.push({ name: m[1].trim(), level: m[2] || m[1].match(/\d$/)?.[0] || "1", qty: parseInt(m[3]) });
        }

        const renderSlotGroups = (multiSlots, defaultIcon) => {
            return multiSlots.map(group => {
                const icon = group.icon || defaultIcon;
                // FIXED: Filter out 0 slots to prevent [0 0] display
                const validSlots = group.slots.filter(s => s > 0);
                if (validSlots.length === 0) return '';

                return `
                    <div class="mhw-slot-row">
                        ${validSlots.map(s => `
                            <div class="mhw-slot-box" data-lv="${s}">
                                ${icon ? `<img src="${icon}" class="mhw-icon-img" style="opacity: 0.3">` : ''}
                                [${s}] Empty Slot
                            </div>
                        `).join('')}
                    </div>`;
            }).join('');
        };

        card.innerHTML = `
            ${buildName ? `<div class="mhw-build-title-display">${buildName}</div>` : ''}
            <div class="mhw-main-row">
                <div class="mhw-column">
                    <div class="mhw-section-title">Equipment & Slotting</div>
                    <div class="mhw-piece-group" style="border-left-color: #e67e22;">
                        <div class="mhw-piece-header">
                            <img src="${ICONS[weaponType]}" class="mhw-icon-img">
                            ${weaponName || 'Weapon'}
                            ${data.equipment.weaponData.innate.length > 0 ? `<span class="mhw-innate-skills">${data.equipment.weaponData.innate.join(' | ')}</span>` : ''}
                        </div>
                        ${renderSlotGroups(data.equipment.weaponData.multiSlots, ICONS[weaponType])}
                    </div>
                    ${data.equipment.map(e => `
                        <div class="mhw-piece-group">
                            <div class="mhw-piece-header">
                                <img src="${e.img}" class="mhw-icon-img"> ${e.name}
                                ${e.innate.length > 0 ? `<span class="mhw-innate-skills">${e.innate.join(' | ')}</span>` : ''}
                            </div>
                            ${renderSlotGroups(e.multiSlots, e.img)}
                        </div>
                    `).join('')}
                    <div class="mhw-section-title mhw-bank-header" style="margin-top:15px;">Available Decorations</div>
                    <div class="mhw-deco-grid mhw-bank-grid">
                        ${jewelInventory.map((d, idx) => `
                            <div class="mhw-deco-btn" data-idx="${idx}">
                                <span class="mhw-deco-name"><img src="${ICONS[d.level]}" class="mhw-icon-img"> ${d.name}</span>
                                <span class="mhw-deco-qty" id="inv-qty-${idx}">x${d.qty}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="mhw-column">
                    <div class="mhw-section-title">
                        Active Skills
                        <span class="mhw-overcap-legend">Red = Overcapped</span>
                    </div>
                    ${data.skills.map(s => `
                        <div class="mhw-skill-item">
                            <span class="mhw-skill-name">${s.name}</span>
                            <span class="mhw-skill-lv" style="${s.isOvercap ? 'color: #e74c3c;' : ''}">${s.full.includes('Lv') ? s.full.split(' ').pop() : s.full}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
            <div id="mhw-qr-code" class="mhw-qr-container"></div>
        `;

        new QRCode(card.querySelector("#mhw-qr-code"), {
            text: shortUrl,
            width: 80,
            height: 80,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.L
        });

        const updateBankUI = () => {
            let totalAvailable = 0;
            jewelInventory.forEach((d, idx) => {
                const btn = card.querySelector(`.mhw-deco-btn[data-idx="${idx}"]`);
                if (!btn) return;
                const qtyText = btn.querySelector(`#inv-qty-${idx}`);
                if (qtyText) qtyText.innerText = `x${d.qty}`;
                if (d.qty <= 0) { btn.style.display = 'none'; } else { btn.style.display = 'flex'; totalAvailable += d.qty; }
            });
            const header = card.querySelector('.mhw-bank-header');
            if (header) header.style.display = totalAvailable > 0 ? 'flex' : 'none';
        };

        updateBankUI();

        card.querySelectorAll('.mhw-deco-btn').forEach(btn => {
            btn.onclick = () => {
                const idx = parseInt(btn.dataset.idx);
                if (jewelInventory[idx].qty <= 0) return;
                if (selectedDeco && selectedDeco.idx === idx) { selectedDeco = null; btn.classList.remove('selected'); }
                else { card.querySelectorAll('.mhw-deco-btn').forEach(b => b.classList.remove('selected')); selectedDeco = { ...jewelInventory[idx], idx }; btn.classList.add('selected'); }
            };
        });

        card.querySelectorAll('.mhw-slot-box').forEach(slot => {
            const removeDeco = () => {
                const currentInSlot = slot.dataset.itemName;
                if (currentInSlot) {
                    const item = jewelInventory.find(i => i.name === currentInSlot);
                    if (item) item.qty++;
                    slot.classList.remove('mhw-slot-filled');

                    // In legacy mode, restore original budget if this was a split slot
                    if (isLegacyMode && slot.dataset.originalBudget) {
                        slot.dataset.lv = slot.dataset.originalBudget;
                        delete slot.dataset.originalBudget;
                        // Remove any sibling slot that was created from splitting
                        const nextSlot = slot.nextElementSibling;
                        if (nextSlot && nextSlot.classList.contains('mhw-slot-box') && nextSlot.dataset.wasSplit) {
                            nextSlot.remove();
                        }
                    }

                    slot.innerHTML = `[${slot.dataset.lv}] Empty Slot`;
                    delete slot.dataset.itemName;
                    updateBankUI();
                    return true;
                }
                return false;
            };
            slot.onclick = () => {
                if (removeDeco() && !selectedDeco) return;
                if (selectedDeco && jewelInventory[selectedDeco.idx].qty > 0) {
                    const slotLevel = parseInt(slot.dataset.lv);
                    const decoLevel = parseInt(selectedDeco.level);

                    // Legacy mode budget system
                    if (isLegacyMode && decoLevel < slotLevel) {
                        // Store original budget before splitting
                        if (!slot.dataset.originalBudget) {
                            slot.dataset.originalBudget = slotLevel;
                        }

                        // Fill current slot with the deco
                        slot.classList.add('mhw-slot-filled');
                        slot.innerHTML = `<img src="${ICONS[selectedDeco.level]}" class="mhw-icon-img"> ${selectedDeco.name}`;
                        slot.dataset.itemName = selectedDeco.name;
                        slot.dataset.lv = decoLevel;

                        // Create new slot for remaining budget
                        const remainingBudget = slotLevel - decoLevel;
                        const slotRow = slot.parentElement;
                        const newSlot = document.createElement('div');
                        newSlot.className = 'mhw-slot-box';
                        newSlot.dataset.lv = remainingBudget;
                        newSlot.dataset.wasSplit = 'true';
                        newSlot.innerHTML = `[${remainingBudget}] Empty Slot`;

                        // Insert after current slot
                        slot.after(newSlot);

                        // Attach event handlers to new slot
                        attachSlotHandlers(newSlot);

                        jewelInventory[selectedDeco.idx].qty--;
                        if (jewelInventory[selectedDeco.idx].qty <= 0) {
                            card.querySelector(`.mhw-deco-btn[data-idx="${selectedDeco.idx}"]`).classList.remove('selected');
                            selectedDeco = null;
                        }
                        updateBankUI();
                    } else {
                        // Normal slotting (non-legacy or exact match)
                        slot.classList.add('mhw-slot-filled');
                        slot.innerHTML = `<img src="${ICONS[selectedDeco.level]}" class="mhw-icon-img"> ${selectedDeco.name}`;
                        slot.dataset.itemName = selectedDeco.name;
                        jewelInventory[selectedDeco.idx].qty--;
                        if (jewelInventory[selectedDeco.idx].qty <= 0) {
                            card.querySelector(`.mhw-deco-btn[data-idx="${selectedDeco.idx}"]`).classList.remove('selected');
                            selectedDeco = null;
                        }
                        updateBankUI();
                    }
                }
            };
            slot.oncontextmenu = (e) => { e.preventDefault(); removeDeco(); };
        });

        // Helper function to attach handlers (for dynamically created slots)
        function attachSlotHandlers(slot) {
            const removeDeco = () => {
                const currentInSlot = slot.dataset.itemName;
                if (currentInSlot) {
                    const item = jewelInventory.find(i => i.name === currentInSlot);
                    if (item) item.qty++;
                    slot.classList.remove('mhw-slot-filled');
                    slot.innerHTML = `[${slot.dataset.lv}] Empty Slot`;
                    delete slot.dataset.itemName;
                    updateBankUI();
                    return true;
                }
                return false;
            };
            slot.onclick = () => {
                if (removeDeco() && !selectedDeco) return;
                if (selectedDeco && jewelInventory[selectedDeco.idx].qty > 0) {
                    const slotLevel = parseInt(slot.dataset.lv);
                    const decoLevel = parseInt(selectedDeco.level);

                    if (isLegacyMode && decoLevel < slotLevel) {
                        slot.classList.add('mhw-slot-filled');
                        slot.innerHTML = `<img src="${ICONS[selectedDeco.level]}" class="mhw-icon-img"> ${selectedDeco.name}`;
                        slot.dataset.itemName = selectedDeco.name;
                        const oldLevel = slotLevel;
                        slot.dataset.lv = decoLevel;

                        const remainingBudget = oldLevel - decoLevel;
                        const slotRow = slot.parentElement;
                        const newSlot = document.createElement('div');
                        newSlot.className = 'mhw-slot-box';
                        newSlot.dataset.lv = remainingBudget;
                        newSlot.dataset.wasSplit = 'true';
                        newSlot.innerHTML = `[${remainingBudget}] Empty Slot`;
                        slot.after(newSlot);
                        attachSlotHandlers(newSlot);

                        jewelInventory[selectedDeco.idx].qty--;
                        if (jewelInventory[selectedDeco.idx].qty <= 0) {
                            card.querySelector(`.mhw-deco-btn[data-idx="${selectedDeco.idx}"]`).classList.remove('selected');
                            selectedDeco = null;
                        }
                        updateBankUI();
                    } else {
                        slot.classList.add('mhw-slot-filled');
                        slot.innerHTML = `<img src="${ICONS[selectedDeco.level]}" class="mhw-icon-img"> ${selectedDeco.name}`;
                        slot.dataset.itemName = selectedDeco.name;
                        jewelInventory[selectedDeco.idx].qty--;
                        if (jewelInventory[selectedDeco.idx].qty <= 0) {
                            card.querySelector(`.mhw-deco-btn[data-idx="${selectedDeco.idx}"]`).classList.remove('selected');
                            selectedDeco = null;
                        }
                        updateBankUI();
                    }
                }
            };
            slot.oncontextmenu = (e) => { e.preventDefault(); removeDeco(); };
        }
    }

    function initTransformer(wrap) {
        if (wrap.querySelector('.mhw-controls')) return;
        const controls = document.createElement('div');
        controls.className = 'mhw-controls';
        const bInput = document.createElement('input'); bInput.className = 'mhw-input'; bInput.placeholder = 'Build Name';
        const wInput = document.createElement('input'); wInput.className = 'mhw-input'; wInput.placeholder = 'Weapon Name';
        const wSelect = document.createElement('select'); wSelect.className = 'mhw-select';
        ['GS', 'LS','SnS','DB','Ham', 'HH','LNC','GL','SWA','CB','IG','LBG','HBG','Bow'].forEach(t => { const o = document.createElement('option'); o.value = t; o.innerText = t; wSelect.appendChild(o); });
        const legacyLabel = document.createElement('label'); legacyLabel.className = 'mhw-legacy-toggle';
        const legacyCheck = document.createElement('input'); legacyCheck.type = 'checkbox';
        legacyCheck.onchange = (e) => isLegacyMode = e.target.checked;
        legacyLabel.append(legacyCheck, " Legacy Mode (Flat Slots)");
        const genBtn = document.createElement('button'); genBtn.className = 'mhw-action-btn'; genBtn.innerText = "âœ¨ Generate Card";
        const dlBtn = document.createElement('button'); dlBtn.className = 'mhw-action-btn mhw-dl-btn'; dlBtn.innerText = "ðŸ’¾ Save PNG";
        controls.append(bInput, wInput, wSelect, legacyLabel, genBtn, dlBtn);
        wrap.prepend(controls);

        genBtn.onclick = async () => { const data = extractData(wrap); if (data) await renderCard(wrap, data, bInput.value, wInput.value, wSelect.value); };

        dlBtn.onclick = () => {
            const card = wrap.querySelector('.mhw-card-wrapper');
            if (card) {
                setTimeout(() => {
                    html2canvas(card, { backgroundColor: "#0c0c0c", scale: 2, useCORS: true, logging: false }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = `${bInput.value || 'MHW_Build'}.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    });
                }, 100);
            }
        };
    }

    const observer = new MutationObserver((mutations) => {
        mutations.forEach(m => m.addedNodes.forEach(node => {
            if (node.nodeType === 1) node.querySelectorAll('td[colspan="7"] > div').forEach(wrap => initTransformer(wrap));
        }));
    });
    observer.observe(document.body, { childList: true, subtree: true });
})();
